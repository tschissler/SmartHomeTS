@page "/"

@using System.Text;
@using System.Collections.ObjectModel;
@using SmartHome.Web.Components.Libs;
@using Syncfusion.Blazor.Charts;
@using Syncfusion.Blazor.Data;
@using Azure.Data.Tables;
@using DataContracts

@inject MqttController mqttController
@rendermode InteractiveServer

<PageTitle>Temperaturanzeige</PageTitle>

<h1>Temperaturen</h1>
@if (isLoading)
{
    <div class="spinner-container">
        <div class="spinner"></div> 
    </div>
}
<div class="d-flex flex-row">
    @foreach (var item in PartitionKeys)
    {
        <div class="me-3">
            <input type="checkbox" checked="@item.IsChecked" @onchange="() => CheckboxChanged(item)" />
            <label>@item.Label</label>
        </div>
    }
</div>
<div class="d-flex flex-row">
    <div class="me-3">
        <button @onclick="RefreshData">Reload Data</button>
    </div>
    <div class="me-3">
        <input type="checkbox" checked="@autoUpdate" @onchange="() => AutoUpdateChanged()" />
        <label>Auto-Update</label>
    </div>
    <div class="me-3">
        <button @onclick="LoadMoreData">Load More Data</button>
    </div>
    <div class="me-3">
        <button @onclick="HiResData">Minuten</button>
    </div>
    <div class="me-3">
        <button @onclick="LoResData">Stunden</button>
    </div>
</div>
<div class="d-flex flex-row">
    &nbsp;
</div>

<SfChart>
    <ChartPrimaryXAxis ValueType="Syncfusion.Blazor.Charts.ValueType.DateTime" LabelFormat="dd.MMM. HH.mm" LabelRotation="45"></ChartPrimaryXAxis>
    <ChartTooltipSettings Enable="true"></ChartTooltipSettings>

    <ChartSeriesCollection>
        @foreach (var item in PartitionKeys.Where(p => p.IsChecked))
        {
            <ChartSeries Name="@item.Label" XName="LocalTime" YName="Value" Type="ChartSeriesType.Line" DataSource="@ChartData[item.PartitionKey]" Fill="@item.Color">
                <ChartSeriesAnimation Enable="true"></ChartSeriesAnimation>
                <ChartMarker Visible="true" Width="3" Height="3" Shape="ChartShape.Circle">
                </ChartMarker>

            </ChartSeries>
        }
    </ChartSeriesCollection>
    <ChartLegendSettings Visible="true" />
</SfChart>


@code {
    private bool isLoading = false;
    private bool autoUpdate = false;
    private int dataTimeRangeHours = -1;
    private int dataTimeIntervalHours = -1;
    public Dictionary<string, ObservableCollection<DataValueTableEntity>> ChartData = new();
    TableClient table;
    string connectionString = "DefaultEndpointsProtocol=https;AccountName=smarthometsstorage;AccountKey=yRZ84NCODris5jSJpP1tbZO1zxVkTTRSEsn4Yiu5TNyKFIToLOaMDe6whunduEzFT3tFwm95X4lcACDbRQDdPQ==;TableEndpoint=https://smarthometsstorage.table.cosmos.azure.com:443/;";
    string hiResTableName = "SmartHomeClimateRawData";
    string loResTableName = "SmartHomeClimateHourAggregationData";

    private System.Timers.Timer autoRefreshTimer = new System.Timers.Timer(60000);

    public List<CheckableItem> PartitionKeys = new()
    {
        new CheckableItem { Label = "Außentemperatur", PartitionKey = "1c50f3ab6224_temperature", IsChecked = false, Color = "blue" },
        new CheckableItem { Label = "M3 Gästezimmer", PartitionKey = "44dbf3ab6224_temperature", IsChecked = false, Color = "grey" },
        new CheckableItem { Label = "M3 Esszimmer", PartitionKey = "a86d2b286f24_temperature", IsChecked = false, Color = "magenta" }, 
        new CheckableItem { Label = "Batteriesensor", PartitionKey = "1420381fb608_temperature", IsChecked = false, Color = "green" }
    };

    protected override void OnInitialized()
    {
        table = new TableClient(connectionString, hiResTableName);
        autoRefreshTimer.Elapsed += async (sender, e) => await FetchNewData();
    }

    private async Task HiResData()
    {
        table = new TableClient(connectionString, hiResTableName);
        dataTimeRangeHours = -1;
        dataTimeIntervalHours = -1;
        RefreshData();
    }

    private async Task LoResData()
    {
        table = new TableClient(connectionString, loResTableName);
        dataTimeRangeHours = -24;
        dataTimeIntervalHours = -24;
        RefreshData();
    }

    private async Task AutoUpdateChanged()
    {
        autoUpdate = !autoUpdate;
        if (autoUpdate)
        {
            autoRefreshTimer.Start();
        }
        else
        {
            autoRefreshTimer.Stop();
        }
    }

    private async Task<List<DataValueTableEntity>> LoadData(string partitionKey, DateTime startTime, DateTime endTime = new DateTime())
    {
        var queryString =
            $"PartitionKey eq '{partitionKey}' " +
            $"and Time ge datetime'{startTime.ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")}'";
        if (endTime != new DateTime())
        {
            queryString += $" and Time le datetime'{endTime.ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ")}'";
        }
        var query = table.Query<DataValueTableEntity>(queryString);
        return query.ToList();
    }
    
    private async Task FetchNewData()
    {
        foreach (var item in PartitionKeys.Where(p => p.IsChecked))
        {
            var latestValueTime = ChartData[item.PartitionKey].Max(i => i.Time);
            var data = LoadData(item.PartitionKey, latestValueTime).Result;

            foreach(var resultItem in data.OrderBy(i => i.Time))
            {
                ChartData[item.PartitionKey].Add(resultItem);
            }
        }

        // Notify the component to refresh the UI
        InvokeAsync(StateHasChanged);
    }
    
    private async Task CheckboxChanged(CheckableItem item)
    {
        await LoadingSpinnerShow();
        try
        {
            if (!item.IsChecked)
            {
                item.IsChecked = true;
                var data = LoadData(item.PartitionKey, DateTime.UtcNow.AddHours(dataTimeRangeHours)).Result;
                ChartData.Add(item.PartitionKey, new ObservableCollection<DataValueTableEntity>(data.OrderBy(i => i.Time)));
            }
            else
            {
                item.IsChecked = false;
                if (ChartData.ContainsKey(item.PartitionKey))
                {
                    ChartData.Remove(item.PartitionKey);
                }
            }
        }
        catch (Exception)
        {
            throw;
        }
        finally
        {
            await LoadingSpinnerHide();
        }
    }

    private async Task RefreshData()
    {
        await LoadingSpinnerShow();

        try
        {
            ChartData = new();
            foreach (var item in PartitionKeys.Where(p => p.IsChecked))
            {
                var data = LoadData(item.PartitionKey, DateTime.UtcNow.AddHours(dataTimeRangeHours)).Result;
                ChartData.Add(item.PartitionKey, new ObservableCollection<DataValueTableEntity>(data.OrderBy(i => i.Time)));
            }

            // Notify the component to refresh the UI
            InvokeAsync(StateHasChanged);
        }
        catch (Exception)
        {
            throw;
        }
        finally
        {
            await LoadingSpinnerHide();
        }
    }

    public async Task LoadingSpinnerShow()
    {
        isLoading = true;
        await Task.Delay(5);
        InvokeAsync(StateHasChanged);
    }

    public async Task LoadingSpinnerHide()
    {
        isLoading = false;
        await Task.Delay(5);
        InvokeAsync(StateHasChanged);
    }
    
    private async Task LoadMoreData(MouseEventArgs e)
    {
        await LoadingSpinnerShow();
        try
        {
            dataTimeRangeHours += dataTimeIntervalHours;

            foreach (var item in PartitionKeys.Where(p => p.IsChecked))
            {
                var earliestTimestamp = ChartData[item.PartitionKey].First().Time;

                var data = LoadData(item.PartitionKey, DateTime.UtcNow.AddHours(dataTimeRangeHours), earliestTimestamp).Result;

                foreach(var resultItem in data.OrderByDescending(i => i.Time))
                {
                    ChartData[item.PartitionKey].Insert(0,resultItem);
                }
            }
            InvokeAsync(StateHasChanged);
        }
        catch (Exception)
        {
            throw;
        }
        finally
        {
            await LoadingSpinnerHide();
        }
    }
}